{"version":3,"sources":["store/root-reducer.ts","store/index.ts","home/index.tsx","games/puzzle-2048/components/header/index.tsx","games/puzzle-2048/components/grid/index.tsx","games/puzzle-2048/components/grid-cell/index.tsx","games/puzzle-2048/components/grid-row/index.tsx","games/puzzle-2048/components/tile/behavior.tsx","games/puzzle-2048/components/tile/index.tsx","games/puzzle-2048/components/tile-container/index.tsx","games/puzzle-2048/helpers/getFurthestDestination.ts","games/puzzle-2048/helpers/getMoveVector.ts","games/puzzle-2048/helpers/getNextCellInDirection.ts","games/puzzle-2048/helpers/getRandomTiles.ts","games/puzzle-2048/helpers/getTilesFromGrid.ts","games/puzzle-2048/helpers/isEmpty.ts","games/puzzle-2048/helpers/getTraversals.ts","games/puzzle-2048/helpers/isMergeable.ts","games/puzzle-2048/helpers/isMovesAvailable.ts","games/puzzle-2048/helpers/isObstacle.ts","games/puzzle-2048/helpers/isSamePosition.ts","games/puzzle-2048/helpers/isTargetMet.ts","games/puzzle-2048/model.ts","games/puzzle-2048/helpers/isWithinBounds.ts","games/puzzle-2048/helpers/initializeGrid.ts","games/puzzle-2048/helpers/keyboardInputHandler.ts","games/puzzle-2048/helpers/mergeTile.ts","games/puzzle-2048/helpers/moveTile.ts","games/puzzle-2048/logic/withGameStateHandlers.ts","games/puzzle-2048/config.ts","games/puzzle-2048/logic/withLifecycle.ts","games/puzzle-2048/logic/onMoveHandler.ts","games/concentration/model.ts","games/puzzle-2048/logic/afterMoveHandler.ts","games/puzzle-2048/logic/withTilesProps.ts","games/puzzle-2048/index.tsx","games/concentration/components/flip-card/behavior.ts","games/concentration/components/flip-card/index.tsx","games/concentration/components/loader/index.tsx","games/concentration/service/index.ts","games/concentration/helper/index.ts","games/concentration/logic/withGameStateHandlers.ts","games/concentration/logic/withCardsComparison.ts","games/concentration/logic/withGameFlow.ts","games/concentration/logic/withLifecycle.ts","games/concentration/index.tsx","routes/index.tsx","serviceWorker.ts","index.tsx"],"names":["rootReducer","history","combineReducers","router","connectRouter","createBrowserHistory","store","initialState","enhancer","composeWithDevTools","createStore","configureStore","Home","react_default","a","createElement","className","Link","to","Header","_ref","score","bestScore","react","Grid","_ref$gridSize","gridSize","size","rows","index","key","concat","push","grid_row","rowSize","_getRows","GridCell","GridRow","cells","grid_cell","_getCells","withStyleProps","withProps","props","classNames","position","x","y","value","compose","TileContainer","tiles","map","tile","components_tile","id","_getTiles","getFurthestDestination","grid","directionVector","destination","getNextCellInDirection","isObstacle","MAP","getMoveVector","direction","cell","createTile","Math","random","availableCells","floor","length","getRandomTiles","tilesCount","arguments","undefined","_grid","cloneDeep","emptyPositions","i","getTilesFromGrid","isEmpty","getTraversals","vector","_step","array","Array","from","keys","xs","slice","reverse","ys","traversals","_iterator","_createForOfIteratorHelper","s","n","done","_step2","_iterator2","err","e","f","isMergeable","mergeCell","isWithinBounds","isMovesAvailable","isSamePosition","p1","p2","Direction","isTargetMet","target","isTargetMet_createForOfIteratorHelper","boundary","initializeGrid","fill","KEYBOARD_MAP","38","Up","39","Right","40","Down","37","Left","keyboardInputHandler","event","callbackMove","which","preventDefault","mergeTile","moveTile","gameOver","gameWon","withGameStateHandlers","withStateHandlers","initGame","state","setGrid","winGame","finishGame","withLifecycle","lifecycle","componentWillMount","_this","this","document","addEventListener","onMove","componentWillUnmount","_this2","removeEventListener","GameDifficulty","onMoveHandler","withHandlers","gridChanged","onMoveHandler_createForOfIteratorHelper","forMerge","mergeable","afterMove","afterMoveHandler","withTilesProps","header","components_grid","tile_container","flipped","found","onClick","content","lib_default","height","src","Loader","message","_fetchCards","api","cards","card","toString","svg","getCards","Object","asyncToGenerator","regenerator_default","mark","_callee","level","sliced","duplicated","wrap","_context","prev","next","Promise","resolve","setTimeout","sent","levelCards","duplicateCards","abrupt","shuffleDeck","stop","_x","apply","beginner","mediun","advanced","flatMap","objectSpread","shuffle","loading","startingTime","started","gameDifficulty","startNewGame","startTimer","Date","now","toggleFlips","_len2","cardIds","_key2","cardsIds","filter","_card","includes","Error","each","setFounds","_len","_key","toggleHoldCard","cardId","cardOnHold","withCardsComparison","cardsComparison","currentCard","cardId2","split","withGameFlow","onCardClick","helper_createForOfIteratorHelper","allFoundCards","_componentWillMount","loader","clickHandler","flip_card","_getFlipCards","routes","Switch","Route","exact","path","component","Concentration","Puzzle2048","render","home","RoutesConnector","esm","Boolean","window","location","hostname","match","Root","es","src_routes","BrowserRouter","basename","process","src_Root","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ac0ce27c.chunk.js","sourcesContent":["import { combineReducers } from \"redux\";\nimport { connectRouter } from \"connected-react-router\";\nimport { StateType } from \"typesafe-actions\";\nimport { History } from \"history\";\n\n// import { xReducer } from '../game/x';\n\nconst rootReducer = (history: History) => combineReducers({\n    router: connectRouter(history),\n  // x: xReducer,\n});\n\nexport type RootState = StateType<typeof rootReducer>;\n\nexport default rootReducer;\n","import { createStore } from \"redux\";\nimport { createBrowserHistory } from \"history\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\n\nimport rootReducer from \"./root-reducer\";\n\nexport const history = createBrowserHistory();\n\n\nfunction configureStore(initialState?: {}) {\n  // configure middlewares\n  // const middlewares = [createEpicMiddleware(rootEpic)];\n  // compose enhancers\n  // const enhancer = composeWithDevTools(applyMiddleware(...middlewares));\n  const enhancer = composeWithDevTools();\n\n  // create store\n  return createStore(rootReducer(history), initialState!, enhancer);\n}\n\n// pass an optional param to rehydrate state on app start\nconst store = configureStore();\n\n// export store singleton instance\nexport default store;\n","import React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Home: React.FC = () => (\n  <div className=\"Home\">\n    <header className=\"home-header\">\n      <h1>Welcome to React Games</h1>\n      <h3>This is a collection of classic games developped using react.</h3>\n    </header>\n    <ul className=\"home-menu\">\n      <li>\n        <Link to=\"/\">Home</Link>\n      </li>\n      <li>\n        <Link to=\"/concentration\">Concentration</Link>\n      </li>\n      <li>\n        <Link to=\"/2048\">2048</Link>\n      </li>\n    </ul>\n  </div>\n);\n\nexport default Home;\n","import * as React from \"react\";\n\nimport \"./styles.scss\";\n\ntype Props = {\n  score: number;\n  bestScore: number;\n};\n\nconst Header: React.FC<Props> = ({ score, bestScore }) => (\n  <div className=\"header\">\n    <h1 className=\"title\">2048</h1>\n    <div className=\"scores-container\">\n      <div className=\"score\">Score: {score}</div>\n      <div className=\"best-score\">Best Score: {bestScore}</div>\n    </div>\n  </div>\n);\n\nexport default Header;\n","import * as React from \"react\";\nimport { GridRow } from \"../index\";\n\nimport \"./styles.scss\";\n\nexport const _getRows = (size: number) => {\n  const rows = [];\n\n  for (let index = 0; index < size; index++) {\n    const key = `row_${index}`;\n    rows.push(<GridRow key={key} rowSize={size} />);\n  }\n\n  return rows;\n};\n\ntype Props = {\n  gridSize?: number;\n};\n\nconst Grid: React.FC<Props> = ({ gridSize = 4 }) => (\n  <div className=\"grid\">{_getRows(gridSize)}</div>\n);\n\nexport default Grid;\n","import * as React from \"react\";\n\nimport \"./styles.scss\";\n\nconst GridCell: React.FC = () => <div className=\"grid-cell\" />;\n\nexport default GridCell;\n","import * as React from \"react\";\nimport { GridCell } from \"../index\";\n\nimport \"./styles.scss\";\n\nexport const _getCells = (size: number) => {\n  const cells = [];\n\n  for (let key = 0; key < size; key++) {\n    cells.push(<GridCell key={key} />);\n  }\n\n  return cells;\n};\n\ntype Props = {\n  rowSize: number;\n};\n\nconst GridRow: React.FC<Props> = ({ rowSize }) => (\n  <div className=\"grid-row\">{_getCells(rowSize)}</div>\n);\n\nexport default GridRow;\n","import { withProps } from \"recompose\";\nimport classNames from \"classnames\";\n\nimport { Position } from \"../../model\";\n\nexport type Props = {\n  position: Position;\n  value: number;\n};\n\nexport type WithProps = {\n  className: string;\n};\n\nexport type TileProps = Props & WithProps;\n\nconst _positionClassName = (position: Position) =>\n  `tile-position-${position.x + 1}-${position.y + 1}`;\n\nconst _valueClassName = (value: number) => `tile-${value}`;\n\nexport const newProps = (props: Props) => ({\n  className: classNames(\n    \"tile\",\n    _positionClassName(props.position),\n    _valueClassName(props.value)\n  )\n});\n\nexport const withStyleProps = withProps(newProps);\n","import * as React from \"react\";\nimport { compose } from \"recompose\";\nimport { TileProps, Props, withStyleProps } from \"./behavior\";\n\nimport \"./styles.scss\";\n\nconst Tile: React.FC<TileProps> = ({ className, value }) => (\n  <div className={className}>\n    <div className=\"tile-content\">{value}</div>\n  </div>\n);\n\nexport default compose<TileProps, Props>(withStyleProps)(Tile);\n","import * as React from \"react\";\nimport { Tile } from \"../index\";\nimport { Tile as TileModel } from \"../../model\";\n\nimport \"./styles.scss\";\n\nexport const _getTiles = (tiles: TileModel[]) =>\n  tiles.map(tile => (\n    <Tile\n      key={tile.id}\n      position={tile.position}\n      value={tile.value}\n    />\n  ));\n\ntype Props = {\n  tiles: TileModel[];\n};\n\nconst TileContainer: React.FC<Props> = ({ tiles }) => (\n  <div className=\"tile-container\">{_getTiles(tiles)}</div>\n);\n\nexport default TileContainer;\n","import { Grid, Position } from \"../model\";\nimport { isObstacle, getNextCellInDirection } from \"./index\";\n\nconst getFurthestDestination = (\n  grid: Grid,\n  tile: Position,\n  directionVector: Position\n): Position => {\n  const destination = getNextCellInDirection(tile, directionVector);\n  if (isObstacle(grid, destination)) {\n    // console.log(`${destination.x} ${destination.y} Sup yo`);\n    return tile;\n  }\n  return getFurthestDestination(grid, destination, directionVector);\n};\n\nexport default getFurthestDestination;\n","import { Direction, Position } from \"../model\";\n\nconst MAP: Position[] = [\n  { x: 0, y: -1 }, // Up = 1\n  { x: 1, y: 0 }, // Right\n  { x: 0, y: 1 }, // Down\n  { x: -1, y: 0 } // Left\n];\n\nexport const getMoveVector = (direction: Direction) => MAP[direction - 1];\n\nexport default getMoveVector;\n","import { Position } from \"../model\";\n\nconst getNextCellInDirection = (\n  cell: Position,\n  directionVector: Position\n) => ({\n  x: cell.x + directionVector.x,\n  y: cell.y + directionVector.y\n});\n\nexport default getNextCellInDirection;\n","import { cloneDeep } from \"lodash\";\nimport { Grid, Position, Tile } from \"../model\";\n\nexport const availableCells = (grid: Grid) => {\n  const emptyPositions: Position[] = [];\n  for (let x = 0; x < grid.length; x++) {\n    for (let y = 0; y < grid.length; y++) {\n      if (!grid[x][y]) {\n        emptyPositions.push({ x, y });\n      }\n    }\n  }\n\n  return emptyPositions;\n};\n\nexport const getRandomValue = () => (Math.random() < 0.8 ? 2 : 4);\n\nexport const getRandomAvailableCell = (availableCells: Position[]) => {\n  return availableCells[Math.floor(Math.random() * availableCells.length)];\n};\n\nexport const createTile = (cells: Position[]): Tile => ({\n  value: getRandomValue(),\n  position: getRandomAvailableCell(cells)!\n});\n\nconst getRandomTiles = (grid: Grid, tilesCount = 1) => {\n  const _grid = cloneDeep(grid);\n  const cells = availableCells(_grid);\n\n  for (let i = 0; i < tilesCount && cells.length; i++) {\n    const tile = createTile(cells);\n    _grid[tile.position.x][tile.position.y] = tile.value;\n  }\n  return _grid;\n};\n\nexport default getRandomTiles;\n","import { Grid, Tile } from \"../model\";\nimport { isEmpty } from \".\";\n\nconst getTilesFromGrid = (grid: Grid): Tile[] => {\n  const tiles = [];\n  for (let x = 0; x < grid.length; x++) {\n    for (let y = 0; y < grid.length; y++) {\n      const position = { x, y };\n      if (!isEmpty(grid, position)) {\n        tiles.push({\n          id: `${x}_${y}`,\n          value: grid[x][y],\n          position\n        });\n      }\n    }\n  }\n\n  return tiles;\n};\n\nexport default getTilesFromGrid;\n","import { Grid, Position } from \"../model\";\n\nconst isEmpty = (grid: Grid, cell: Position) => !grid[cell.x][cell.y];\n\nexport default isEmpty;\n","import { Grid, Position } from \"../model\";\nimport isEmpty from \"./isEmpty\";\n\nexport const getTraversals = (grid: Grid, vector: Position) => {\n  const array = Array.from(Array(grid.length).keys()); // [0, 1, 2, 3... size]\n\n  // Always traverse from the farthest cell in the chosen direction\n  const xs = (vector.x === 1) ? array.slice().reverse() : array.slice(); // if we're moving right we reverse xs\n  const ys = (vector.y === 1) ? array.slice().reverse() : array.slice(); // if we're moving down we reverse ys\n\n  const traversals: Position[] = [];\n  for (const x of xs) {\n    for (const y of ys) {\n      if (!isEmpty(grid, { x, y })) {\n        traversals.push({ x, y });\n      }\n    }\n  }\n\n  return traversals;\n};\n\nexport default getTraversals;\n","import { Grid, Position } from \"../model\";\nimport { getNextCellInDirection, isWithinBounds, isEmpty } from \"./index\";\n\nconst isMergeable = (grid: Grid, mergeCell: Position, value: number) => {\n  if (!isWithinBounds(mergeCell, grid.length)) {\n    return false;\n  }\n\n  if (grid[mergeCell.x][mergeCell.y] !== value) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default isMergeable;\n","import { Grid } from \"../model\";\n\nconst isMovesAvailable = (grid: Grid) => {\n  // TODO: implement.\n  return true;\n};\n\nexport default isMovesAvailable;\n","import { Grid, Position } from \"../model\";\nimport { isWithinBounds, isEmpty } from \"./index\";\n\nconst isObstacle = (grid: Grid, cell: Position) => (\n  !isWithinBounds(cell, grid.length) ||\n  !isEmpty(grid, cell)\n);\n\nexport default isObstacle;\n","import { Position } from \"../model\";\n\nconst isSamePosition = (p1: Position, p2: Position) =>\n  p1.x === p2.x && p1.y === p2.y;\n\nexport default isSamePosition;\n","import { Grid } from \"../model\";\n\nconst isTargetMet = (grid: Grid, target: number) => {\n  for (const row of grid) {\n    for (const tile of row) {\n      if (tile === target) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nexport default isTargetMet;\n","import { StateHandlers, GameState } from \"./logic/withGameStateHandlers\";\n\nexport type Grid = number[][];\n\nexport type Position = {\n  x: number;\n  y: number;\n};\n\nexport type Tile = {\n  id?: string;\n  value: number;\n  position: Position;\n};\n\nexport enum Direction {\n  Up = 1,\n  Right,\n  Down,\n  Left\n}\n\nexport type Handlers = {\n  onMove: (direction: Direction) => void;\n  afterMove: () => void;\n};\n\nexport type WithProps = {\n  tiles: Tile[];\n};\n\nexport type GameProps = GameState & StateHandlers & WithProps & Handlers;\n","import { Position } from \"../model\";\n\nconst isWithinBounds = (position: Position, boundary: number) =>\n  position.x >= 0 &&\n  position.x < boundary &&\n  position.y >= 0 &&\n  position.y < boundary;\n\nexport default isWithinBounds;\n","import { Grid } from \"../model\";\n\nconst initializeGrid = (size: number): Grid => Array(size).fill(null).map(() => Array(size).fill(0));\n\nexport default initializeGrid;\n","import { Direction } from \"../model\";\nimport { GameState } from \"../logic/withGameStateHandlers\";\n\ntype KeyboardMap = {\n  [key: number] : Direction;\n};\n\nconst KEYBOARD_MAP: KeyboardMap = {\n  38: Direction.Up,\n  39: Direction.Right,\n  40: Direction.Down,\n  37: Direction.Left\n};\n\n/**\n * Prevent calling state hundler function on unsupported keyboard inputs.\n * @param event KeyboardEvent\n * @param callbackMove StateHandler to invoke on user input.\n */\nexport const keyboardInputHandler = (\n  event: KeyboardEvent,\n  callbackMove: (d: Direction) => void\n) => {\n  const direction = KEYBOARD_MAP[event.which];\n\n  if (direction) {\n    event.preventDefault();\n    callbackMove(direction);\n  }\n};\n\nexport default keyboardInputHandler;\n","import { Grid, Position } from \"../model\";\n\nconst mergeTile = (grid: Grid, tile: Position, destination: Position) => {\n  const _grid = grid;\n\n  _grid[destination.x][destination.y] *= 2;\n  _grid[tile.x][tile.y] = 0;\n\n  return _grid;\n};\n\nexport default mergeTile;\n","import { Grid, Position } from \"../model\";\n\nconst moveTile = (grid: Grid, tile: Position, destination: Position) => {\n  const _grid = grid;\n  _grid[destination.x][destination.y] = grid[tile.x][tile.y];\n  _grid[tile.x][tile.y] = 0;\n\n  return _grid;\n};\n\nexport default moveTile;\n","import { withStateHandlers } from \"recompose\";\n\nimport { getRandomTiles, initializeGrid } from \"../helpers\";\nimport { Grid } from \"../model\";\nimport { GRID_SIZE } from \"../config\";\n\nexport type GameState = {\n  score: number;\n  gameOver: boolean;\n  gameWon: boolean;\n  grid: Grid;\n};\n\nexport type StateHandlers = {\n  initGame: () => Partial<GameState>;\n  setGrid: (grid: Grid) => Partial<GameState>;\n  winGame: () => Partial<GameState>;\n  finishGame: () => Partial<GameState>;\n};\n\nconst initialState: GameState = {\n  score: 0,\n  gameOver: false,\n  gameWon: false,\n  grid: initializeGrid(GRID_SIZE)\n};\n\nexport const loadGamefromCache = () => () => {\n  throw Error(\"Not Implemented\");\n};\n\nexport const initGame = (state: GameState) => () => ({\n  grid: getRandomTiles(state.grid, 3)\n});\n\nexport const setGrid = () => (grid: Grid) => ({\n  grid\n});\n\nexport const winGame = () => () => ({\n  gameWon: true\n});\n\nexport const finishGame = () => () => ({\n  gameOver: true\n});\n\nexport const withGameStateHandlers =\n  withStateHandlers<GameState, StateHandlers>(initialState, {\n    initGame,\n    setGrid,\n    winGame,\n    finishGame\n  });\n\nexport default withGameStateHandlers;\n","export const WIN_TARGET = 2048;\nexport const GRID_SIZE = 4;\n","import { lifecycle } from \"recompose\";\n\nimport { GameProps } from \"../model\";\nimport { keyboardInputHandler } from \"../helpers/keyboardInputHandler\";\n\nexport const withLifecycle = lifecycle<GameProps, {}>({\n  componentWillMount() {\n    this.props.initGame();\n\n    document.addEventListener(\"keydown\", (event: KeyboardEvent) =>\n      keyboardInputHandler(event, this.props.onMove)\n    );\n  },\n\n  // TODO: reference check memory leak.\n  componentWillUnmount() {\n    document.removeEventListener(\"keydown\", (event: KeyboardEvent) =>\n      keyboardInputHandler(event, this.props.onMove)\n    );\n  }\n});\n\nexport default withLifecycle;\n","import { withHandlers } from \"recompose\";\nimport { cloneDeep } from \"lodash\";\n\nimport { GameProps, Direction } from \"../model\";\n\nimport {\n  getTraversals,\n  getFurthestDestination,\n  getMoveVector,\n  isMergeable,\n  isSamePosition,\n  moveTile,\n  mergeTile,\n  getNextCellInDirection\n} from \"../helpers\";\n\nexport const onMove = (props: GameProps) => (direction: Direction) => {\n  let grid = cloneDeep(props.grid);\n  const directionVector = getMoveVector(direction);\n  const traversals = getTraversals(grid, directionVector);\n\n  // Traverse the grid and try to move/merge tiles\n  let gridChanged = false;\n  for (const tile of traversals) {\n    const destination = getFurthestDestination(grid, tile, directionVector);\n    const forMerge = getNextCellInDirection(destination, directionVector);\n\n    const mergeable = isMergeable(grid, forMerge, grid[tile.x][tile.y]);\n    const samePosition = isSamePosition(tile, destination);\n\n    if (samePosition && !mergeable) {\n      continue; // blocked tile either by boundary or adjacent tile.\n    }\n\n    grid = mergeable\n      ? mergeTile(grid, tile, forMerge)\n      : moveTile(grid, tile, destination);\n    gridChanged = true;\n  }\n\n  if (gridChanged) {\n    props.setGrid(grid);\n    props.afterMove();\n  }\n};\n\nexport const onMoveHandler = withHandlers({\n  onMove\n});\n\nexport default onMoveHandler;\n","import { StateHandlers, GameState } from \"./logic/withGameStateHandlers\";\n\nexport interface Card {\n  id: string;\n  svg: string;\n  flipped: boolean;\n  found: boolean;\n  isDuplicate?: boolean;\n}\n\nexport enum GameDifficulty {\n  beginner = 1,\n  mediun,\n  advanced\n}\n\nexport type Handlers = {\n  cardsComparison: (cardOnHold: string, currentCard: string) => void;\n  onCardClick: (card: Card) => void;\n};\n\nexport type GameProps = GameState & StateHandlers & Handlers;","import { withHandlers } from \"recompose\";\nimport { cloneDeep } from \"lodash\";\n\nimport { GameProps } from \"../model\";\n\nimport { getRandomTiles, isMovesAvailable, isTargetMet } from \"../helpers\";\n\nimport { WIN_TARGET } from \"../config\";\n\nexport const afterMove = (props: GameProps) => () => {\n  let grid = cloneDeep(props.grid);\n  if (isTargetMet(grid, WIN_TARGET)) {\n    props.winGame();\n  }\n\n  grid = getRandomTiles(grid);\n  props.setGrid(grid);\n\n  if (!isMovesAvailable(grid)) {\n    props.finishGame(); // Game over!\n  }\n};\n\nexport const afterMoveHandler = withHandlers({\n  afterMove\n});\n\nexport default afterMoveHandler;\n","import { withProps } from \"recompose\";\n\nimport { GameProps } from \"../model\";\nimport { getTilesFromGrid } from \"../helpers\";\n\nconst withTilesProps = withProps<{}, GameProps>(({ grid }) => ({ tiles: getTilesFromGrid(grid) }));\n\nexport default withTilesProps;\n","import * as React from \"react\";\nimport { compose } from \"recompose\";\n\nimport { Header, Grid, TileContainer } from \"./components\";\nimport { GameProps } from \"./model\";\nimport { withGameStateHandlers, withTilesProps, withLifecycle, onMoveHandler, afterMoveHandler } from \"./logic\";\n\nimport \"./styles.scss\";\n\nconst Puzzle2048: React.FC<GameProps> = ({ tiles, score, gameWon }) => (\n  <div>\n    <Header score={score} bestScore={1024} />\n    {gameWon && <h2>Congratulations !!</h2>}\n    <div className=\"game-container\">\n      <Grid />\n      <TileContainer tiles={tiles} />\n    </div>\n  </div>\n);\n\nexport default compose<GameProps, {}>(\n  withGameStateHandlers,\n  withTilesProps,\n  afterMoveHandler,\n  onMoveHandler,\n  withLifecycle\n)(Puzzle2048);\n","import { withProps } from \"recompose\";\nimport classNames from \"classnames\";\n\nexport type Props = {\n  onClick: () => void;\n  flipped: boolean;\n  found: boolean;\n  content: string;\n};\n\nexport type WithProps = {\n  className: string;\n};\n\nexport type FlipCardProps = Props & WithProps;\n\nexport const newProps = (props: Props) => ({\n  className: classNames(\"flipcard\", {\n    \"flipped\": props.flipped || props.found,\n    \"found\": props.found\n  })\n});\n\nexport const withStyleProps = withProps(newProps);\n","import * as React from \"react\";\nimport { compose } from \"recompose\";\nimport LazyLoad from \"react-lazyload\";\n\nimport { FlipCardProps, Props, withStyleProps } from \"./behavior\";\n\nimport \"./styles.scss\";\n\nconst FlipCard: React.FC<FlipCardProps> = ({ onClick, content, className }) => (\n  <div className={className} onClick={onClick}>\n    <div className=\"flipcard-inner front\">\n      <LazyLoad height={200}>\n        <img src={content} />\n      </LazyLoad>\n    </div>\n    <div className=\"flipcard-inner back\" />\n  </div>\n);\n\nexport default compose<FlipCardProps, Props>(withStyleProps)(FlipCard);\n","import * as React from \"react\";\n\nimport \"./styles.scss\";\n\ntype Props = {\n  message?: string;\n};\n\nconst Loader: React.FC<Props> = ({ message }) => (\n  <div className=\"loader-container\">\n    <span className=\"loader\" />\n    <span className=\"message\" >{message}</span>\n  </div>\n);\n\nexport default Loader;\n","import api from \"../mock/index.json\";\nimport { Card } from \"../model.js\";\n\nconst _fetchCards = () => {\n  return api.cards.map(card => ({\n    id: card.id.toString(),\n    svg: card.svg,\n    flipped: false,\n    found: false\n  }));\n};\n\nexport function fetchCards(): Promise<Card[]> {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(_fetchCards());\n    }, 1000);\n  });\n}\n","import { find, each, flatMap, shuffle, includes } from \"lodash\";\nimport { fetchCards } from \"../service\";\nimport { Card, GameDifficulty } from \"../model\";\n\nexport const getCards = async (level: number) => {\n  const cards = await fetchCards();\n  const sliced = levelCards(cards, level);\n  const duplicated = duplicateCards(sliced);\n\n  return shuffleDeck(duplicated);\n};\n\n// TODO: implement pagination on server side.\nexport const levelCards = (cards: Card[], level: GameDifficulty) => {\n  switch (level) {\n    case GameDifficulty.beginner:\n      return cards.slice(0, 1);\n\n    case GameDifficulty.mediun:\n      return cards.slice(0, 3);\n\n    case GameDifficulty.advanced:\n      return cards.slice(0, 5);\n\n    default:\n      return cards;\n  }\n};\n\nexport const duplicateCards = (cards: Card[]) =>\n  flatMap(cards, card => [card, { ...card, id: `${card.id}_1` }]);\n\nexport const shuffleDeck = (cards: Card[]) => shuffle(cards);\n\nexport const flippedCard = (cards: Card[]) =>\n  find(cards, card => !card.found && card.flipped);\n\nexport const matchingCards = (cardId1: string, cardId2: string) =>\n  cardId1.split(\"_\")[0] === cardId2.split(\"_\")[0];\n\nexport const setFoundCards = (cards: Card[], cardsIds: string[]) =>\n  each(cards, card => {\n    if (includes(cardsIds, card.id)) {\n      card.found = true;\n    }\n  });\n\nexport const setFlippedCards = (cards: Card[], cardsIds: string[]) =>\n  each(cards, card => {\n    if (includes(cardsIds, card.id)) {\n      card.flipped = true;\n    }\n  });\n\nexport const unsetFlippedCards = (cards: Card[], cardsIds: string[]) =>\n  each(cards, card => {\n    if (includes(cardsIds, card.id)) {\n      card.flipped = false;\n    }\n  });\n\nexport const toggleFlippedCards = (cards: Card[], cardsIds: string[]) =>\n  each(cards, card => {\n    if (includes(cardsIds, card.id)) {\n      card.flipped = !card.flipped;\n    }\n  });\n\nexport const allFoundCards = (cards: Card[]) => {\n  for (const card of cards) {\n    if (!card.found) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const startTimer = () => ({\n  started: true,\n  startingTime: Date.now()\n});\n","import { withStateHandlers, StateHandler } from \"recompose\";\nimport { includes, filter } from \"lodash\";\n\nimport {\n  toggleFlippedCards,\n  setFoundCards\n} from \"../helper\";\nimport { Card, GameDifficulty } from \"../model\";\n\nexport interface GameState {\n  loading: boolean;\n  cards: Card[];\n  startingTime: number;\n  started: boolean;\n  gameDifficulty: GameDifficulty;\n  cardOnHold?: string;\n  gameWon: boolean;\n}\n\nexport type StateHandlers = {\n  initGame: () => StateHandler<GameState>;\n  startNewGame: (cards: Card[]) => StateHandler<GameState>;\n  startTimer: () => StateHandler<GameState>;\n  toggleHoldCard: (cardId?: string) => StateHandler<GameState>;\n  toggleFlips: (...cardIds: string[]) => StateHandler<GameState>;\n  setFounds: (...cardIds: string[]) => StateHandler<GameState>;\n  winGame: () => StateHandler<GameState>;\n};\n\nconst initialState: GameState = {\n  loading: false,\n  cards: [],\n  startingTime: 0,\n  started: false,\n  gameDifficulty: 0,\n  gameWon: false\n};\n\nexport const loadGamefromCache = () => () => {\n  throw Error(\"Not Implemented\");\n};\n\nexport const initGame = () => () => ({\n  loading: true\n});\n\nexport const startNewGame = () => (cards: Card[]) => ({\n  cards,\n  loading: false\n});\n\nexport const startTimer = () => () => ({\n  started: true,\n  startingTime: Date.now()\n});\n\n\nexport const winGame = () => () => ({\n  gameWon: true\n});\n\nexport const toggleHoldCard = () => (cardId?: string) => {\n  return cardId\n    ? {\n        cardOnHold: cardId\n      }\n    : {\n        cardOnHold: undefined\n      };\n};\n\nexport const setFounds = (state: GameState) => (...cardIds: string[]) => {\n  const cardsInDeck = filter(state.cards, _card => includes(cardIds, _card.id));\n  if (!cardsInDeck.length) {\n    throw Error(\"No card was found\");\n  }\n\n  return {\n    cards: setFoundCards(state.cards, cardIds)\n  };\n};\n\nexport const toggleFlips = (state: GameState) => (...cardIds: string[]) => {\n  const cardsInDeck = filter(state.cards, _card => includes(cardIds, _card.id));\n  if (!cardsInDeck.length) {\n    throw Error(\"No card was found\");\n  }\n\n  return {\n    cards: toggleFlippedCards(state.cards, cardIds)\n  };\n};\n\nexport const withGameStateHandlers = withStateHandlers(initialState, {\n  initGame,\n  startNewGame,\n  startTimer,\n  toggleFlips,\n  setFounds,\n  toggleHoldCard,\n  winGame\n});\n\nexport default withGameStateHandlers;","import { withHandlers } from \"recompose\";\n\nimport { matchingCards } from \"../helper\";\nimport { GameProps } from \"../model\";\n\nexport const cardsComparison = (props: GameProps) => (\n  cardOnHold: string,\n  currentCard: string\n) => {\n  if (matchingCards(cardOnHold, currentCard)) {\n    props.setFounds(cardOnHold, currentCard);\n  } else {\n    props.toggleFlips(cardOnHold, currentCard);\n  }\n\n  props.toggleHoldCard();\n};\n\nexport const withCardsComparison = withHandlers({\n  cardsComparison\n});\n\nexport default withCardsComparison;","import { withHandlers } from \"recompose\";\n\nimport { GameProps, Card } from \"../model\";\nimport { allFoundCards } from \"../helper\";\n\nexport const onCardClick = (props: GameProps) => (card: Card) => {\n  if (!props.started) {\n    props.startTimer();\n  }\n\n  if (card.found || card.flipped) {\n    return;\n  }\n  props.toggleFlips(card.id);\n\n  // Handle the first flipped card.\n  const { cardOnHold } = props;\n  if (!cardOnHold) {\n    props.toggleHoldCard(card.id);\n    return;\n  }\n\n  // Handle second card flip and Delay comparison for a good UX\n  setTimeout(() => {\n    props.cardsComparison(cardOnHold, card.id);\n  }, 1000);\n\n  // Check if game is won.\n  // TODO: test this new flow.\n  setTimeout(() => {\n    if (allFoundCards(props.cards)) {\n      props.winGame();\n    }\n  }, 1000);\n};\n\nexport const withGameFlow = withHandlers({\n  onCardClick\n});\n\nexport default withGameFlow;\n","import { lifecycle } from \"recompose\";\n\nimport { getCards } from \"../helper\";\nimport { GameProps } from \"../model\";\n\nexport const withLifecycle = lifecycle<GameProps, {}>({\n  async componentWillMount() {\n    this.props.initGame();\n    const cards = await getCards(this.props.gameDifficulty);\n    this.props.startNewGame(cards);\n  }\n});\n\nexport default withLifecycle;","import * as React from \"react\";\nimport { compose } from \"recompose\";\n\nimport { GameProps, Card } from \"./model\";\nimport { FlipCard, Loader } from \"./components\";\nimport {\n  withGameStateHandlers,\n  withCardsComparison,\n  withGameFlow,\n  withLifecycle\n} from \"./logic\";\n\nconst _getFlipCards = (cards: Card[], clickHandler: (card: Card) => void) =>\n  cards.map(card => (\n    <FlipCard\n      onClick={() => clickHandler(card)}\n      key={card.id}\n      content={card.svg}\n      flipped={card.flipped}\n      found={card.found}\n    />\n  ));\n\nconst Concentration: React.FC<GameProps> = ({\n  loading,\n  gameWon,\n  cards,\n  onCardClick\n}) => (\n  <div className=\"Concentration\">\n    <div className=\"header\">\n      <h2>Concentration</h2>\n      <h4>Memory game with matching cards.</h4>\n      {gameWon && <h3>Congrats!</h3>}\n    </div>\n    {loading ? (\n      <Loader message={\"Loading Cards...\"} />\n    ) : (\n      _getFlipCards(cards, onCardClick)\n    )}\n  </div>\n);\n\nexport default compose<GameProps, {}>(\n  withGameStateHandlers,\n  withCardsComparison,\n  withGameFlow,\n  withLifecycle\n)(Concentration);\n","import React from \"react\";\nimport { History } from \"history\";\nimport { ConnectedRouter } from \"connected-react-router\";\nimport { Route, Switch } from \"react-router\";\n\nimport Home from \"../home\";\nimport Puzzle2048 from \"../games/puzzle-2048\";\nimport Concentration from \"../games/concentration\";\n\ntype RouterProps = {\n  history: History;\n};\n\nconst routes = (\n  <Switch>\n    <Route exact={true} path=\"/\" component={Home} />\n    <Route exact={true} path=\"/concentration\" component={Concentration} />\n    <Route exact={true} path=\"/2048\" component={Puzzle2048} />\n    <Route render={() => <div><Home /></div>} />\n    {/* <Route exact path={`/home`} render={ (routerProps) => < Home routerProps={routerProps} setUpGame={this.setUpGame} />} /> */}\n  </Switch>\n);\n\nconst RoutesConnector: React.FC<RouterProps> = ({ history }) => (\n  <ConnectedRouter history={history}>{routes}</ConnectedRouter>\n);\n\nexport default RoutesConnector;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          // tslint:disable-next-line:no-console\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit http://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              // tslint:disable-next-line:no-console\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              // tslint:disable-next-line:no-console\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      // tslint:disable-next-line:no-console\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      // tslint:disable-next-line:no-console\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import \"tslib\";\n\nimport React from \"react\";\nimport { render } from \"react-dom\";\nimport { Provider } from \"react-redux\";\n\nimport store, { history } from \"./store\";\nimport RoutesConnector from \"./routes\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nimport { BrowserRouter as Router } from \"react-router-dom\";\n\nconst Root = () => (\n  <Provider store={store}>\n    <RoutesConnector history={history} />\n  </Provider>\n);\n\nrender(<Router basename={process.env.PUBLIC_URL}><Root /></Router>, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}